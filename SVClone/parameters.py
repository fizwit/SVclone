import numpy as np

# PREPROCESSING PARAMETERS
tr      = 5    # "wobble length" tolerance threshold which we allow breaks to be inexact
window  = 500  # base-pairs considered to the left and right of the break TODO: this really should be chosen based on the fraglen
gl_th   = 10   # SVs considered germline if matching by at least this many bp, when comparing set of breaks to germline

valid_chroms    = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', \
                   '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', 'X', 'Y']

# parameters extracted for each read from BAMs
read_dtype = [('query_name', 'S150'), ('chrom', 'S50'), ('ref_start', int), ('ref_end', int), \
              ('align_start', int), ('align_end', int), ('len', int), ('ins_len', int), ('is_reverse', np.bool)]

# PHYL constant parameters
subclone_threshold      = 0.05 # throw out any subclones with frequency lower than this value
subclone_sv_prop        = 0.08 # remove any cluster groups with fewer than this proportion of SVs clustering together
subclone_diff           = 0.10 # merge any clusters within this range
tolerate_svloss         = 0.30 # recluster if we lose more than x% of SVs from clustering/filtering
clus_limit              = 20 # maximum number of clusters generated by dirichlet process
cnv_proximity           = 200000 # max bp proximity SVs will be considered to border CNV boundaries
sv_offset               = 500000 # shift SV pos this far (in the SVs directionalit) to match CNV states
#beta_shape              = 0.8
#beta_rate               = 1/0.8

# SV classification class names
inversion_class          = ['INV']
deletion_class           = ['DEL']
dna_gain_class           = ['DUP','INTDUP']
itrx_class               = ['INTRX']

#####################################################################
# Output dtypes
#####################################################################

# SV copy-number output
sv_cn_dtype =  [('chr1','S50'),
             ('pos1',int),
             ('total_copynumber1',int),
             ('no_chrs_bearing_mutation1',int),
             ('chr2','S50'),
             ('pos2',int),
             ('total_copynumber2',int),
             ('no_chrs_bearing_mutation2',int)]

# SV most likely copy-numbers output
sv_mlcn_dtype =[('chr1','S50'),
             ('pos1',int),
             ('chr2','S50'),
             ('pos2',int),
             ('pos1_bb_CN','S50'),
             ('pos2_bb_CN','S50'),
             ('most_likely_ref_copynumber',int),
             ('most_likely_variant_copynumber',int),
             ('prop_chrs_bearing_mutation',float),
             ('support',int),
             ('depth',int),      
             ('pv',float)]

# SV multiplicities output
sv_mult_dtype =[('chr1','S50'),
             ('pos1',int),
             ('chr2','S50'),
             ('pos2',int),
             ('tumour_copynumber',int),
             ('multiplicity',int),
             ('tumour_copynumber_options','S50'),
             ('multiplicity_options','S50'),
             ('probabilities','S50')]

# SNV copy-number output
snv_cn_dtype =  [('chr','S50'),
             ('pos',int),
             ('total_copynumber',int),
             ('no_chrs_bearing_mutation',int)]

# SNV most likely copy-number output
snv_mlcn_dtype =[('chr','S50'),
             ('pos',int),
             ('bb_CN','S50'),
             ('most_likely_ref_copynumber',int),
             ('most_likely_variant_copynumber',int),
             ('prop_chrs_bearing_mutation',float)]

# SNV multiplicities output
snv_mult_dtype =[('chr','S50'),
             ('pos',int),
             ('tumour_copynumber',int),
             ('multiplicity',int),
             ('tumour_copynumber_options','S50'),
             ('multiplicity_options','S50'),
             ('probabilities','S50')]
